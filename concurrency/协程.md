### 什么是协程
协程可以理解为特殊的子程序  
传统的子程序：A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。这是一种层级的调用关系。  
协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。  
注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。
```
# 利用协程实现生产者消费者，生产者每生产一个，马上通知消费者来消费。整个流程无锁，由一个线程执行

def consumer():
    r = ''
    while True:
        # 接受调用者发出的参数
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        # r表示接受的返回值
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)
```

### 优点
- 执行效率高，开销小。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
- 不需要多线程的锁机制。因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

### 如何利用多核CPU
因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

### 异步IO（AIO）
本质：读完了再通知我  
`asyncio`是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。

## 延伸知识点
Java的NIO是同步非阻塞的。虽然在NIO的网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身还是同步的。

而对于AIO来说，则是更近了一步，它不是在IO准备好时再通知线程，而是在操作已经完成后，再给线程发出通知。因此，AIO是完全不会阻塞的。（不要死磕字面含义，与NIO相比，不过是异步的程度不同而已，AIO异步得更彻底！）

## 参考
《Java高并发程序设计》  
[廖雪峰：python教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000)
